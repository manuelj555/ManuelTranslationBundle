<?php
/*
 * This file is part of the Manuel Aguirre Project.
 *
 * (c) Manuel Aguirre <programador.manuel@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace ManuelAguirre\Bundle\TranslationBundle\Translation\Dumper;

use ManuelAguirre\Bundle\TranslationBundle\Entity\Translation;
use ManuelAguirre\Bundle\TranslationBundle\Entity\TranslationRepository;
use ManuelAguirre\Bundle\TranslationBundle\Entity\TranslationValue;
use Symfony\Component\Translation\Dumper\DumperInterface;
use Symfony\Component\Translation\MessageCatalogue;


/**
 * @autor Manuel Aguirre <programador.manuel@gmail.com>
 */
class DoctrineDumper implements DumperInterface
{

    /**
     * @var TranslationRepository
     */
    protected $translationRepository;
    /**
     * @var \Doctrine\Common\Persistence\ObjectManager
     */
    protected $em;
    protected $locales;

    function __construct($em, $translationRepository, $locales)
    {
        $this->em = $em;
        $this->translationRepository = $translationRepository;
        $this->locales = $locales;
    }


    /**
     * Dumps the message catalogue.
     *
     * @param MessageCatalogue $messages The message catalogue
     * @param array            $options  Options that are used by the dumper
     */
    public function dump(MessageCatalogue $messages, $options = array())
    {
        set_time_limit(10);
        $translations = $this->getExistentTranslations();

        $locale = $messages->getLocale();
        //actualizamos las etiquetas de la BD en base al catálogo
        $translations = $this->setFromCatalogue($messages, $translations, $options);

        $counter = 0;

        foreach ($translations as $domain => $items) {
            foreach ($items as $t) {
                $this->em->persist($t);
                /*
                 * Se comenta el flush debido a que al parecer, se estan creando nuevos objetos en vez de actualizar
                 */
//                if (($counter++ % 20) === 0) {
//                    $this->em->flush();
//                    $this->em->clear();
//                }
            }
        }

        $this->em->flush();
        $this->em->clear();
    }

    public function getExistentTranslations()
    {
        $items = $this->translationRepository->findAll();

        $result = array();

        foreach ($items as $e) {
            $result[$e->getDomain()][$e->getCode()] = $e;
        }

        return $result;
    }

    public function dumpCatalogues($catalogues)
    {
        $translations = $this->getExistentTranslations();

        foreach ($catalogues as $messages) {
            set_time_limit(10);
            $translations = $this->setFromCatalogue($messages, $translations, array());
        }

        $counter = 0;

        foreach ($translations as $domain => $items) {
            foreach ($items as $t) {
                $this->em->persist($t);

//                if (($counter++ % 50) === 0) {
//                    $this->em->flush();
//                    $this->em->clear();
//                }
            }
        }

        $this->em->flush();
        $this->em->clear();
    }

    /**
     * Actualiza/Crea traducciones en el arreglo $translations.
     *
     * @param MessageCatalogue $catalogue
     * @param                  $translations
     * @param array            $options
     *
     * @return mixed
     */
    protected function setFromCatalogue(MessageCatalogue $catalogue, $translations, $options = array())
    {
        $locale = $catalogue->getLocale();

        foreach ($catalogue->all() as $domain => $items) {
            foreach ($items as $code => $value) {

                if (isset($translations[$domain][$code])) {
                    $values = $translations[$domain][$code]->getValues();
                    if (!isset($values[$locale]) OR isset($options['restoring'])) {
                        //si no existe el valor de traduccion en el locale actual
                        $translations[$domain][$code]->setValue($locale, $value);
                    }

                    if (!isset($options['restoring'])) {
                        //si se está usando, lo activamos
                        $translations[$domain][$code]->setActive(true);
                    }

                } else {
                    $t = $translations[$domain][$code] = new Translation($code, $domain);

                    $t->setValue($locale, $value);
                    $t->setNew(true);
                    $t->setAutogenerated(true);
                    $t->setActive(true);
                }
            }
        }

        return $translations;
    }
}